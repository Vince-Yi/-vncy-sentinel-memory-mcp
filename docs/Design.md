# Sentinel-Memory MCP Design Document

- Date: 2026-02-27
- Version: 0.5.0

---

## 1. Project Overview

### 1-1. Purpose

- Record and reuse **Prompt Gaps** that occur while LLMs (Cursor/Claude) are working
- Eliminate repetitive background explanations on every task to reduce token consumption
- Accumulate knowledge in Git-managed text files for team-wide sharing

### 1-2. Core Principles

- Do not store source code
- Store only summaries and questions generated by the LLM after each task
- Manage simply with a single file (`.context/memory_log.jsonl`)
- Claude directly judges relevance — no vector embeddings
- Compress in units of 50 records by default to control file size and token consumption

### 1-3. Expected Benefits

| Benefit | Description |
|---------|-------------|
| Token savings | Reference only core logs. No lengthy background explanations needed |
| Fewer trial-and-errors | Past failure history is automatically surfaced before the next task |
| Onboarding automation | Months of LLM know-how instantly available after `git pull` |
| Minimal dependencies | No ML libraries. Runs on `fastmcp` + `filelock` only |

---

## 2. System Architecture

### 2-1. Structure

```
Cursor AI (Claude)
    │
    │  [1] search_memory(query, topic?)
    │      └─ Returns entire memory_log.jsonl
    │         If topic is specified, returns only exact-match entries
    │         Claude directly judges relevant entries (no vector search)
    │
    │  [2] Code modification (Cursor file access, MCP not used)
    │
    │  [3] log_memory(topic, missing_context, lesson, ...)
    │      └─ Append/upsert to .context/memory_log.jsonl
    │
    │  [4] compact_memory() required when records exceed 50
    │      └─ Returns topic-grouped records + similar topic merge suggestions
    │         → Claude summarizes → log_memory(type=principle)
    │
    ▼
MCP Server (FastMCP, Python)
    └── core/store.py      ─ JSONL read/write/upsert + filelock + atomic write
    └── core/sanitizer.py  ─ Sensitive information filter
```

### 2-2. Project Path Resolution

The MCP server receives the target project root via the `cwd` setting in `.cursor/mcp.json`.

```json
{
    "mcpServers": {
        "sentinel-memory": {
            "command": "C:/tools/sentinel-memory/.venv/Scripts/python.exe",
            "args": ["C:/tools/sentinel-memory/server.py"],
            "cwd": "D:/projects/my-app"
        }
    }
}
```

- `server.py` uses the path `Path.cwd() / ".context" / "memory_log.jsonl"`
- `.context/` directory is automatically created on first write if it does not exist
- Only the `cwd` in `.cursor/mcp.json` needs to change per project
- Global installation, per-project path specification are separated

### 2-3. Workflow (3-Step Loop)

```
━━━ [Step 1] Pre-Task: Context retrieval and questioning ━━━━━━━━━━━━━━━━

User: "Fix the payment module"
    │
    ▼
search_memory("payment module")
    │
    ├─ Records found ──► Return entire memory_log.jsonl to Claude
    │                    Claude selects relevant lessons + ask_next_time and presents them
    │                    e.g. "Last time there was an error due to missing VAT logic.
    │                          Shall we confirm the applicable countries for tax calculation?"
    │
    └─ No records ──► Generate Gap Analysis questions
                      e.g. "Does this module have external API dependencies?"
                           "Is there a previously attempted approach that failed?"


━━━ [Step 2] Post-Task: Knowledge extraction and recording ━━━━━━━━━━━━━━━

After task completion, LLM self-analyzes and calls log_memory

log_memory(
    topic           = "payment",
    missing_context = "VAT calculation differs by country, not stated in initial instructions",
    lesson          = "Always check the country-code tax rate file when modifying the payment module",
    ask_next_time   = "What is the country scope for this modification?"
)


━━━ [Step 3] Compact: Knowledge compression (default 50 records, required) ━━━━

When records exceed compact_threshold, Claude must call compact_memory

compact_memory(compact_threshold=50)
    │
    ├─ Returns topic-grouped record bundles + similar topic merge suggestions to Claude
    ├─ Claude: decides on similar topic consolidation, then summarizes lesson list
    └─ Saves via log_memory(type="principle", ...) then deletes originals
```

---

## 3. MCP Tool Definitions

### 3-1. search_memory

```
Input:
    query  (string)         Search keyword or task description
    topic  (string, opt)    Pre-filter by specific topic

Output: Entire contents of memory_log.jsonl (only the specified topic if given)
```

- No vector operations. Returns the entire file as-is
- When `topic` is specified, returns only records with an **exact match** to the stored value (partial match not supported)
- Claude directly judges relevant entries from the returned records
- Returns Gap Analysis guidance text when the file is empty

**Output example (records found):**

```
[memory_log - 3 entries]

#1 type=log | topic=payment | 2026-02-27
missing_context: VAT calculation differs by country, not stated in initial instructions
lesson: Always check the country-code tax rate file when modifying the payment module
ask_next_time: What is the country scope for this modification?

#2 type=principle | topic=payment | compacted: 2026-03-15 (7 merged)
lesson: Payment module: check country tax rates, separate refund API, PG timeout 10s
ask_next_time: Confirm applicable countries and PG provider type first
...
```

**Output example (no records):**

```
No related past records found.
Please ask the user the following:
1. Are there core constraints for this module?
2. Are there external library version requirements?
3. Is there a previously attempted approach that failed?
```

> Output format is a human-readable example. Not a parsing target and not an official spec.

---

### 3-2. log_memory

```
Input:
    topic             (string)        Task subject tag (length >= 1 after trim)
                                      e.g. auth, payment, css-layout
    missing_context   (string)        Information absent from initial instructions but required
    lesson            (string)        Rules or constraints to apply on the next task
    ask_next_time     (string, opt)   Confirmation question to ask the user before the next task
    type              (string, opt)   "log" (default) or "principle" (Compact result)
    compact_threshold (int,    opt)   Compact trigger count (default 50)

Output: Save confirmation + current record count + required compact notice (if exceeded)
```

**ID generation rules:**

| type | ID input | Meaning |
|------|----------|---------|
| `log` | `topic + missing_context` | Upsert when the same missing info recurs |
| `principle` | `topic + lesson` | Upsert when the same principle is re-saved |

- Hash: SHA-256 applied to UTF-8 encoded bytes, first 16 characters used
- `ValueError` if `topic` is an empty string or whitespace only
- Includes required compact notice when record count exceeds `compact_threshold` after saving
- File write: atomic write (create temp file then rename) + `filelock`

---

### 3-3. compact_memory

```
Input:
    target_topic      (string, opt)  Process only a specific topic (all topics if omitted)
    compact_threshold (int,    opt)  Default 50

Output: Topic-grouped record list + similar topic merge suggestions
        (Claude summarizes and calls log_memory)
```

- **Required** when record count exceeds `compact_threshold`
- **Delegated to Claude**: the tool returns only topic-grouped data + similar topic candidate list
- Claude in-context:
    1. Decides whether to consolidate similar topics (e.g. `"auth"`, `"auth-login"` → `"auth"`)
    2. Summarizes lesson list per consolidated topic → saves via `log_memory(type="principle")`
    3. Concatenates original log `ask_next_time` values and merges within 512-byte limit
- **Deletion order**: original records deleted only after successful principle save
- **Deletion scope**: only the snapshot ID list at the time of compact call (excludes subsequently added logs)
- Git preserves before/after change history

**Flow:**

```
compact_memory(compact_threshold=50) called
    │
    ▼
Returns topic-grouped record bundles + similar topic candidates (passed to Claude)
    │
    ▼
Claude: decides on similar topic consolidation
        summarizes lesson list per topic → one core principle sentence
        concatenates ask_next_time → merges within 512-byte limit
    │
    ▼
log_memory(type="principle", topic=..., lesson=summary, ask_next_time=merged)
    │
    ▼ (after confirming principle save success)
Delete original log records (store.delete_by_ids, based on snapshot ID list)
```

---

## 4. Data Format

### 4-1. .context/memory_log.jsonl (single unified file)

One line = one memory record. **No vector fields.**

**General record (type=log):**

```json
{
    "id": "a1b2c3d4e5f6a7b8",
    "type": "log",
    "topic": "payment",
    "missing_context": "VAT calculation differs by country, not stated in initial instructions",
    "lesson": "Always check the country-code tax rate file when modifying the payment module",
    "ask_next_time": "What is the country scope for this modification?",
    "meta": {
        "created": "2026-02-27T10:30:00+00:00"
    }
}
```

**Compacted principle (type=principle):**

```json
{
    "id": "b2c3d4e5f6a7b8c9",
    "type": "principle",
    "topic": "payment",
    "missing_context": "",
    "lesson": "Payment module: check country tax rates, separate refund policy, PG timeout fixed at 10s",
    "ask_next_time": "Confirm applicable countries and PG provider type first",
    "meta": {
        "created": "2026-03-15T09:00:00+00:00",
        "compacted_at": "2026-03-15T09:00:00+00:00",
        "source_count": 7
    }
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `id` | string | Y | First 16 chars of SHA-256 generated by type-specific rule (UTF-8 bytes) |
| `type` | string | Y | `log` or `principle` |
| `topic` | string | Y | Task subject tag (UTF-8 <= 64 bytes, length >= 1 after trim) |
| `missing_context` | string | Y | Required information that was absent (UTF-8 <= 1,024 bytes) |
| `lesson` | string | Y | Rules to apply next time (UTF-8 <= 1,024 bytes) |
| `ask_next_time` | string | - | Confirmation question before next task (UTF-8 <= 512 bytes) |
| `meta.created` | string | Y | ISO 8601 UTC. `log`=save time, `principle`=principle creation time |
| `meta.compacted_at` | string | - | Compact execution time (`principle` only) |
| `meta.source_count` | int | - | Number of source records merged (`principle` only) |

> Byte limits are based on UTF-8 byte length. `ValueError` is raised if exceeded (truncation not supported).

---

## 5. Module Details

### 5-1. core/store.py

**Role:** `.context/memory_log.jsonl` CRUD, size validation, file lock

**Policies:**

- `.context/` directory is automatically created on first write (`mkdir(parents=True, exist_ok=True)`)
- File write: create temp file then rename (atomic write). Raises explicit exception on failure
- On JSONL read, skip malformed lines and continue loading. Log the number of skipped lines
- File lock: lock only during read/write I/O. Compact's summarization and log_memory call steps run outside the lock
- `delete_by_ids`: deletes only the snapshot ID list at compact call time. Called only after successful principle save

**Size limits (UTF-8 byte length):**

| Field | Limit | On exceed |
|-------|-------|-----------|
| `topic` | 64 bytes | `ValueError` |
| `missing_context` | 1,024 bytes | `ValueError` |
| `lesson` | 1,024 bytes | `ValueError` |
| `ask_next_time` | 512 bytes | `ValueError` |

**Key functions:**

| Function | Description |
|----------|-------------|
| `upsert_log(record)` | Upsert by ID, with filelock + atomic write |
| `delete_by_ids(ids)` | Delete originals during compact, with filelock |
| `read_all(topic=None)` | Read all, or filter by exact topic match |
| `count()` | Return record count |

**File lock:**

```python
from filelock import FileLock
lock = FileLock(str(MEMORY_LOG_PATH) + ".lock")
with lock:
    # Read/write I/O section only (minimize lock duration)
```

### 5-2. core/sanitizer.py

**Role:** Remove sensitive information from log_memory input

- Applied fields: only `missing_context` and `lesson` (minimize false positive risk)
- `topic` and `ask_next_time` are excluded (short structured values, high false positive risk)
- API key / token patterns replaced with `[REDACTED]`
- After REDACTED substitution, the ID hash may differ from the original (saved as a new record — intentional design choice)

---

## 6. .cursorrules (Enforced Workflow)

```
You are the 'memory manager' of this project.
All tasks are performed based on .context/memory_log.jsonl.

[Before task start — required]
1. Call the search_memory tool to retrieve related past records.
2. Directly judge which lessons from the returned records are relevant to the current task.
3. If related records exist, reference the lessons and confirm ask_next_time questions with the user.
4. If no related records exist, do not guess — ask the user about core constraints.

[After task completion — required]
5. Call the log_memory tool.
   - Information absent from initial instructions but required → missing_context
   - Rules that must be known for the next task → lesson
   - Questions to confirm first next time → ask_next_time

[Topic writing guidelines]
- Write at a mid-level scope based on module or feature units. (Language/framework agnostic)
- Correct examples: auth, payment, api-gateway, ui-form, db-migration
- Too narrow (prohibited): login_bug_fix_2026, verify_token_v2
- Too broad (prohibited): code, backend, fix
- Check the existing topic list first; reuse a similar topic instead of creating a new one.
  e.g. If "auth-login" already exists, use "auth-login" instead of creating "authentication"

[Compact — required when records exceed 50]
6. Call compact_memory to receive topic-grouped records.
7. Consolidate similar topics if any. (e.g. "auth", "auth-login" → "auth")
8. Summarize each topic's lesson list into one core principle sentence.
9. Concatenate each topic's ask_next_time and merge within 512-byte limit.
10. Save the summary via log_memory(type="principle", ...).
11. After confirming principle save success, request deletion of original log records.

Skipping this sequence is not permitted.
```

---

## 7. Size and Performance Plan

### 7-1. memory_log.jsonl Expected Size (after vector removal)

| Situation | Size |
|-----------|------|
| 1 record (text only) | ~0.5 KB |
| 50 records (max before compact) | ~25 KB |
| After compact (5–10 principles) | ~3–5 KB |
| Long-term steady state | 10–30 KB |

### 7-2. search_memory Context Usage

| Record count | Size | Approx. tokens | Claude context ratio |
|--------------|------|----------------|----------------------|
| 50 records (max before compact) | ~25 KB | ~6,250 tokens | 3.1% (vs 200K) |
| 10 records after compact | ~5 KB | ~1,250 tokens | 0.6% |

- Even before compact, context usage stays below 3% — negligible token overhead
- Removing vector fields reduces file size by 75% compared to the previous design

### 7-3. Dependency Comparison

| Item | Previous design | Current design |
|------|-----------------|----------------|
| ML libraries | sentence-transformers (~2.5 GB) | None |
| Core dependencies | fastmcp, numpy, sentence-transformers | fastmcp, filelock |
| Installation time | 5–15 minutes | Seconds |
| First-run model download | Required | Not needed |

---

## 8. Security Considerations

- Filter `missing_context` and `lesson` fields via `sanitizer.py` before saving (only two fields to minimize false positives)
- `filelock` prevents file corruption during concurrent writes
- Force stdout UTF-8 encoding at the top of `server.py` (prevents garbled Korean on Windows)
- `.context/` directory is Git-tracked (source code not included)
- Consider adding `.context/` to `.gitignore` for sensitive projects
- Recommend running `git diff .context/` before pushing to remote
- Duplicate saving is possible after REDACTED substitution changes the ID (permitted — intentional design choice)

---

## 9. Design Decisions

| Item | Decision | Notes |
|------|----------|-------|
| Vector embeddings | Removed | Claude directly judges relevance |
| Search method | Return all, Claude judges | Pre-filtering available via topic parameter |
| Topic filter | Exact match only | Partial match not supported |
| Topic normalization | Claude consolidates similar topics during compact | cursorrules includes topic reuse guidelines |
| `log` ID | First 16 chars of SHA-256 of `topic + missing_context` (UTF-8) | Upsert on same missing info |
| `principle` ID | First 16 chars of SHA-256 of `topic + lesson` (UTF-8) | Upsert on same principle |
| Byte limit basis | UTF-8 byte length | ValueError on exceed, truncation not supported |
| `topic` validity | Length >= 1 after trim | Empty topic prohibited |
| `topic` tags | Free input + .cursorrules guidelines control scope | Similar topics consolidated during compact |
| Compact threshold | Default 50, adjustable via parameter | `compact_threshold` |
| Compact trigger | Required when exceeding 50 | Enforced, not recommended |
| Compact method | Delegated to current session AI (Cursor/Claude) | Claude summarizes in-context then saves |
| Compact deletion order | Delete only after successful principle save | Atomicity guaranteed |
| Compact deletion scope | Snapshot ID list at call time only | Excludes subsequently added logs |
| `principle` ask_next_time | Concatenate original log ask_next_time within 512 bytes | Excess truncated |
| `principle` search | Returned equally with `log` | No type distinction in processing |
| `meta.created` meaning | `log`=save time, `principle`=principle creation time | |
| sanitizer applied fields | `missing_context` and `lesson` only | Minimize false positive risk |
| REDACTED upsert | Allow saving as new ID | Duplicate increase accepted, intentional choice |
| JSONL corruption handling | Skip malformed lines, continue loading | Log number of skipped lines |
| Write method | Atomic write (temp file + rename) | Explicit exception on disk full |
| .context creation | Auto-created on first write | `mkdir(parents=True, exist_ok=True)` |
| File lock scope | Read/write I/O section only | Compact summarization step runs outside lock |
| Output format | Human-readable example | Not a parsing target |
| Supported languages | All languages (C++, C#, TS, JS, Python, etc.) | Language-neutral field structure |
| Project path | Passed via `cwd` in `.cursor/mcp.json` | Server uses `Path.cwd()` |
| Concurrent write protection | `filelock` library | Works on both Windows and Linux |
| stdout encoding | Force UTF-8 | Handles Korean characters on Windows |

---

## 10. File Structure

```
Target project root/
├── .cursor/
│   └── mcp.json               ← Specify project path via cwd
└── .context/
    └── memory_log.jsonl       ← Git-tracked

dug-sentinel-memory-mcp/      ← MCP server (global installation)
├── docs/
│   ├── Design_KR.md
│   └── Design.md
├── core/
│   ├── __init__.py
│   ├── sanitizer.py           ─ Sensitive info filter (applied to missing_context, lesson)
│   └── store.py               ─ JSONL read/write/upsert + filelock + atomic write
├── server.py                  ─ 3 MCP tools
│                                (search_memory / log_memory / compact_memory)
├── requirements.txt           ─ fastmcp, filelock
├── .cursorrules
└── .gitignore
```
